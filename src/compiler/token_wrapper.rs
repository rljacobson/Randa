/*!

Adapter to use any token type with a Bison parser. The code generated by Bison expects the token type to be named
`Token`, so either call it `Token` or put `use token_wrapper::TokenWrapper as Token` in the use section.

 */

use super::{
  Token,
  Loc,
  TOKEN_BASE
};

pub const BISON_TOKEN_BASE: i32 = 258; // = Lexer::YYError + 2;

/// A token that is emitted by a lexer and consumed by a parser
#[derive(Clone)]
pub struct TokenWrapper {
  /// The token being wrapped.
  pub token: Token,

  /// Location of the token (i.e. range in source code that it refers to)
  pub loc: Loc,
}

use std::fmt;
impl fmt::Debug for TokenWrapper {
  fn fmt(&self, f: &mut fmt::Formatter<'_> /*'*/) -> fmt::Result {
    f.write_str(&format!(
      "[{}, {:?}, {}...{}]",
      token_name(self.token_type()),
      self.token_value,
      self.loc.start,
      self.loc.end
    ))
  }
}

impl TokenWrapper {
  pub(crate) fn from(value: Value) -> TokenWrapper {
    match value {
      Value::Token(v) => v,
      other => panic!("expected Token, got {:?}", other),
    }
  }

  pub(crate) fn token_type(&self) -> i32 {
    (self.token as u32) - TOKEN_BASE + BISON_TOKEN_BASE
  }
}



fn budd() {

}



#[cfg(test)]
mod tests {
  #[test]
  fn it_works() {
    assert_eq!(2 + 2, 4);
  }
}
